{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.propKey = propKey;\nexports.intersection = intersection;\nexports.createRuleSet = createRuleSet;\nexports.createClassName = createClassName;\nexports.castBreakpointsToIntegers = castBreakpointsToIntegers;\nexports.memoize = memoize;\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? Object(arguments[i]) : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys.push.apply(ownKeys, Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n/**\n * Extracts the single breakpoint prop from the props object.\n */\n\n\nfunction propKey(breakpointProps) {\n  return Object.keys(breakpointProps)[0];\n}\n/**\n * Returns the intersection of two arrays.\n */\n\n\nfunction intersection(a1, a2) {\n  return a2 ? a1.filter(function (element) {\n    return a2.indexOf(element) >= 0;\n  }) : _toConsumableArray(a1);\n}\n/**\n * Generate a style rule for a given class name that will hide the element\n * when the given query matches.\n */\n\n\nfunction createRuleSet(className, query) {\n  return \"@media \".concat(query, \"{.\").concat(className, \"{display:none!important;}}\");\n}\n/**\n * Given a list of strings, or string tuples, generates a class name.\n */\n\n\nfunction createClassName() {\n  for (var _len = arguments.length, components = new Array(_len), _key = 0; _key < _len; _key++) {\n    components[_key] = arguments[_key];\n  }\n\n  return [\"fresnel\"].concat(_toConsumableArray(components.reduce(function (acc, breakpoint) {\n    return Array.isArray(breakpoint) ? _toConsumableArray(acc).concat(_toConsumableArray(breakpoint)) : _toConsumableArray(acc).concat([breakpoint]);\n  }, []))).join(\"-\");\n}\n/**\n * Returns an object with every values casted to integers.\n */\n\n\nfunction castBreakpointsToIntegers(breakpoints) {\n  var keys = Object.keys(breakpoints);\n  return keys.reduce(function (previous, current, currentIndex) {\n    return _objectSpread({}, previous, _defineProperty({}, keys[currentIndex], Math.round(Number(breakpoints[current]))));\n  }, {});\n}\n/**\n * Use this function to memoize any function\n */\n\n\nfunction memoize(func) {\n  var results = {};\n  return function () {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    var argsKey = JSON.stringify(args);\n\n    if (!results[argsKey]) {\n      results[argsKey] = func.apply(void 0, args);\n    }\n\n    return results[argsKey];\n  };\n}","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAGA;AACA;AACA;;;AACO,SAASA,OAAT,CAAiBC,eAAjB,EAAwD;EAC7D,OAAOC,MAAM,CAACC,IAAPD,CAAYD,eAAZC,EAA6B,CAA7BA,CAAP;AACD;AAED;AACA;AACA;;;AACO,SAASE,YAAT,CACLC,EADK,EAELC,EAFK,EAGE;EACP,OAAOA,EAAE,GAAGD,EAAE,CAACE,MAAHF,CAAU,mBAAO;IAAA,OAAIC,EAAE,CAACE,OAAHF,CAAWG,OAAXH,KAAuB,CAA3B;EAAjB,EAAH,sBAAwDD,EAAxD,CAAT;AACD;AAED;AACA;AACA;AACA;;;AACO,SAASK,aAAT,CAAuBC,SAAvB,EAA0CC,KAA1C,EAAyD;EAC9D,wBAAiBA,KAAjB,eAA2BD,SAA3B;AACD;AAED;AACA;AACA;;;AACO,SAASE,eAAT,GAEL;EAAA,kCADGC,UACH;IADGA,UACH,MADGA,GACHC,eADGD;EACH;;EACA,OAAO,CACL,SADK,4BAEFA,UAAU,CAACE,MAAXF,CACD,UAACG,GAAD,EAAgBC,UAAhB;IAAA,OACEC,KAAK,CAACC,OAAND,CAAcD,UAAdC,uBACQF,GADR,4BACgBC,UADhB,wBAEQD,GAFR,UAEaC,UAFb,EADF;EADC,GAKD,EALCJ,CAFE,GASLO,IATK,CASA,GATA,CAAP;AAUD;AAED;AACA;AACA;;;AACO,SAASC,yBAAT,CAAmCC,WAAnC,EAEuB;EAC5B,IAAMpB,IAAI,GAAGD,MAAM,CAACC,IAAPD,CAAYqB,WAAZrB,CAAb;EAEA,OAAOC,IAAI,CAACa,MAALb,CACL,UAACqB,QAAD,EAAWC,OAAX,EAAoBC,YAApB;IAAA,yBACKF,QADL,sBAEGrB,IAAI,CAACuB,YAAD,CAFP,EAEwBC,IAAI,CAACC,KAALD,CAAWE,MAAM,CAACN,WAAW,CAACE,OAAD,CAAZ,CAAjBE,CAFxB;EADK,GAKL,EALKxB,CAAP;AAOD;AAED;AACA;AACA;;;AACO,SAAS2B,OAAT,CAAqDC,IAArD,EAA8D;EACnE,IAAMC,OAAO,GAAG,EAAhB;EACA,OAAO,YAAa;IAAA,mCAATC,IAAS;MAATA,IAAS,OAATA,GAASlB,gBAATkB;IAAS;;IAClB,IAAMC,OAAO,GAAGC,IAAI,CAACC,SAALD,CAAeF,IAAfE,CAAhB;;IACA,IAAI,CAACH,OAAO,CAACE,OAAD,CAAZ,EAAuB;MACrBF,OAAO,CAACE,OAAD,CAAPF,GAAmBD,IAAI,MAAJA,SAAQE,IAARF,CAAnBC;IACD;;IACD,OAAOA,OAAO,CAACE,OAAD,CAAd;EALF;AAOD","names":["propKey","breakpointProps","Object","keys","intersection","a1","a2","filter","indexOf","element","createRuleSet","className","query","createClassName","components","arguments","reduce","acc","breakpoint","Array","isArray","join","castBreakpointsToIntegers","breakpoints","previous","current","currentIndex","Math","round","Number","memoize","func","results","args","argsKey","JSON","stringify"],"sources":["../src/Utils.ts"],"sourcesContent":["import { MediaBreakpointProps } from \"./Media\"\nimport { BreakpointConstraintKey } from \"./Breakpoints\"\n\n/**\n * Extracts the single breakpoint prop from the props object.\n */\nexport function propKey(breakpointProps: MediaBreakpointProps) {\n  return Object.keys(breakpointProps)[0] as BreakpointConstraintKey\n}\n\n/**\n * Returns the intersection of two arrays.\n */\nexport function intersection(\n  a1: ReadonlyArray<any>,\n  a2?: ReadonlyArray<any>\n): any[] {\n  return a2 ? a1.filter(element => a2.indexOf(element) >= 0) : [...a1]\n}\n\n/**\n * Generate a style rule for a given class name that will hide the element\n * when the given query matches.\n */\nexport function createRuleSet(className: string, query: string) {\n  return `@media ${query}{.${className}{display:none!important;}}`\n}\n\n/**\n * Given a list of strings, or string tuples, generates a class name.\n */\nexport function createClassName(\n  ...components: Array<string | [string, string]>\n) {\n  return [\n    \"fresnel\",\n    ...components.reduce(\n      (acc: string[], breakpoint) =>\n        Array.isArray(breakpoint)\n          ? [...acc, ...breakpoint]\n          : [...acc, breakpoint],\n      []\n    ),\n  ].join(\"-\")\n}\n\n/**\n * Returns an object with every values casted to integers.\n */\nexport function castBreakpointsToIntegers(breakpoints: {\n  [key: string]: number | string\n}): { [key: string]: number } {\n  const keys = Object.keys(breakpoints)\n\n  return keys.reduce(\n    (previous, current, currentIndex) => ({\n      ...previous,\n      [keys[currentIndex]]: Math.round(Number(breakpoints[current])),\n    }),\n    {}\n  )\n}\n\n/**\n * Use this function to memoize any function\n */\nexport function memoize<F extends (...args: any[]) => void>(func: F) {\n  const results = {}\n  return (...args) => {\n    const argsKey = JSON.stringify(args)\n    if (!results[argsKey]) {\n      results[argsKey] = func(...args)\n    }\n    return results[argsKey]\n  }\n}\n"]},"metadata":{},"sourceType":"script"}