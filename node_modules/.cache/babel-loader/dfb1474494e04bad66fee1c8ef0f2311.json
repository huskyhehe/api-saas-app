{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Breakpoints = exports.BreakpointConstraint = void 0;\n\nvar _Utils = require(\"./Utils\");\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? Object(arguments[i]) : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys.push.apply(ownKeys, Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n\n  var _s, _e;\n\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction breakpointKey(breakpoint) {\n  return Array.isArray(breakpoint) ? breakpoint.join(\"-\") : breakpoint;\n}\n\nvar BreakpointConstraint;\n/**\n * Encapsulates all breakpoint data needed by the Media component. The data is\n * generated on initialization so no further runtime work is necessary.\n */\n\nexports.BreakpointConstraint = BreakpointConstraint;\n\n(function (BreakpointConstraint) {\n  BreakpointConstraint[\"at\"] = \"at\";\n  BreakpointConstraint[\"lessThan\"] = \"lessThan\";\n  BreakpointConstraint[\"greaterThan\"] = \"greaterThan\";\n  BreakpointConstraint[\"greaterThanOrEqual\"] = \"greaterThanOrEqual\";\n  BreakpointConstraint[\"between\"] = \"between\";\n})(BreakpointConstraint || (exports.BreakpointConstraint = BreakpointConstraint = {}));\n\nvar Breakpoints = /*#__PURE__*/function () {\n  _createClass(Breakpoints, null, [{\n    key: \"validKeys\",\n    value: function validKeys() {\n      return [BreakpointConstraint.at, BreakpointConstraint.lessThan, BreakpointConstraint.greaterThan, BreakpointConstraint.greaterThanOrEqual, BreakpointConstraint.between];\n    }\n  }]);\n\n  function Breakpoints(_breakpoints) {\n    var _this = this,\n        _this$_mediaQueries;\n\n    _classCallCheck(this, Breakpoints);\n\n    _defineProperty(this, \"_sortedBreakpoints\", void 0);\n\n    _defineProperty(this, \"_breakpoints\", void 0);\n\n    _defineProperty(this, \"_mediaQueries\", void 0);\n\n    _defineProperty(this, \"findBreakpointsForWidths\", function (fromWidth, throughWidth) {\n      var fromBreakpoint = _this.findBreakpointAtWidth(fromWidth);\n\n      if (!fromBreakpoint) {\n        return undefined;\n      }\n\n      var throughBreakpoint = _this.findBreakpointAtWidth(throughWidth);\n\n      if (!throughBreakpoint || fromBreakpoint === throughBreakpoint) {\n        return [fromBreakpoint];\n      } else {\n        return _this._sortedBreakpoints.slice(_this._sortedBreakpoints.indexOf(fromBreakpoint), _this._sortedBreakpoints.indexOf(throughBreakpoint) + 1);\n      }\n    });\n\n    _defineProperty(this, \"findBreakpointAtWidth\", function (width) {\n      return _this._sortedBreakpoints.find(function (breakpoint, i) {\n        var nextBreakpoint = _this._sortedBreakpoints[i + 1];\n\n        if (nextBreakpoint) {\n          return width >= _this._breakpoints[breakpoint] && width < _this._breakpoints[nextBreakpoint];\n        } else {\n          return width >= _this._breakpoints[breakpoint];\n        }\n      });\n    });\n\n    _defineProperty(this, \"valuesWithBreakpointProps\", function (values) {\n      var max = values.length;\n      var valueBreakpoints = [];\n      var lastTuple;\n\n      _this._sortedBreakpoints.forEach(function (breakpoint, i) {\n        var value = values[i];\n\n        if (i < max && (!lastTuple || lastTuple[0] !== value)) {\n          lastTuple = [value, [breakpoint]];\n          valueBreakpoints.push(lastTuple);\n        } else {\n          lastTuple[1].push(breakpoint);\n        }\n      });\n\n      return valueBreakpoints.map(function (_ref, i) {\n        var _ref2 = _slicedToArray(_ref, 2),\n            value = _ref2[0],\n            breakpoints = _ref2[1];\n\n        var props = {};\n\n        if (i === valueBreakpoints.length - 1) {\n          props.greaterThanOrEqual = breakpoints[0];\n        } else if (breakpoints.length === 1) {\n          props.at = breakpoints[0];\n        } else {\n          // TODO: This is less than ideal, would be good to have a `through`\n          //       prop, which unlike `between` is inclusive.\n          props.between = [breakpoints[0], valueBreakpoints[i + 1][1][0]];\n        }\n\n        return [value, props];\n      });\n    });\n\n    this._breakpoints = _breakpoints;\n    this._sortedBreakpoints = Object.keys(_breakpoints).map(function (breakpoint) {\n      return [breakpoint, _breakpoints[breakpoint]];\n    }).sort(function (a, b) {\n      return a[1] < b[1] ? -1 : 1;\n    }).map(function (breakpointAndValue) {\n      return breakpointAndValue[0];\n    }); // List of all possible and valid `between` combinations\n\n    var betweenCombinations = this._sortedBreakpoints.slice(0, -1).reduce(function (acc, b1, i) {\n      return _toConsumableArray(acc).concat(_toConsumableArray(_this._sortedBreakpoints.slice(i + 1).map(function (b2) {\n        return [b1, b2];\n      })));\n    }, []);\n\n    this._mediaQueries = (_this$_mediaQueries = {}, _defineProperty(_this$_mediaQueries, BreakpointConstraint.at, this._createBreakpointQueries(BreakpointConstraint.at, this._sortedBreakpoints)), _defineProperty(_this$_mediaQueries, BreakpointConstraint.lessThan, this._createBreakpointQueries(BreakpointConstraint.lessThan, this._sortedBreakpoints.slice(1))), _defineProperty(_this$_mediaQueries, BreakpointConstraint.greaterThan, this._createBreakpointQueries(BreakpointConstraint.greaterThan, this._sortedBreakpoints.slice(0, -1))), _defineProperty(_this$_mediaQueries, BreakpointConstraint.greaterThanOrEqual, this._createBreakpointQueries(BreakpointConstraint.greaterThanOrEqual, this._sortedBreakpoints)), _defineProperty(_this$_mediaQueries, BreakpointConstraint.between, this._createBreakpointQueries(BreakpointConstraint.between, betweenCombinations)), _this$_mediaQueries);\n  }\n\n  _createClass(Breakpoints, [{\n    key: \"toVisibleAtBreakpointSet\",\n    value: function toVisibleAtBreakpointSet(breakpointProps) {\n      breakpointProps = this._normalizeProps(breakpointProps);\n\n      if (breakpointProps.lessThan) {\n        var breakpointIndex = this.sortedBreakpoints.findIndex(function (bp) {\n          return bp === breakpointProps.lessThan;\n        });\n        return this.sortedBreakpoints.slice(0, breakpointIndex);\n      } else if (breakpointProps.greaterThan) {\n        var _breakpointIndex = this.sortedBreakpoints.findIndex(function (bp) {\n          return bp === breakpointProps.greaterThan;\n        });\n\n        return this.sortedBreakpoints.slice(_breakpointIndex + 1);\n      } else if (breakpointProps.greaterThanOrEqual) {\n        var _breakpointIndex2 = this.sortedBreakpoints.findIndex(function (bp) {\n          return bp === breakpointProps.greaterThanOrEqual;\n        });\n\n        return this.sortedBreakpoints.slice(_breakpointIndex2);\n      } else if (breakpointProps.between) {\n        var between = breakpointProps.between;\n        var fromBreakpointIndex = this.sortedBreakpoints.findIndex(function (bp) {\n          return bp === between[0];\n        });\n        var toBreakpointIndex = this.sortedBreakpoints.findIndex(function (bp) {\n          return bp === between[1];\n        });\n        return this.sortedBreakpoints.slice(fromBreakpointIndex, toBreakpointIndex);\n      }\n\n      return [];\n    }\n  }, {\n    key: \"toRuleSets\",\n    value: function toRuleSets() {\n      var _this2 = this;\n\n      var keys = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Breakpoints.validKeys();\n      var selectedMediaQueries = keys.reduce(function (mediaQueries, query) {\n        mediaQueries[query] = _this2._mediaQueries[query];\n        return mediaQueries;\n      }, {});\n      return Object.entries(selectedMediaQueries).reduce(function (acc, _ref3) {\n        var _ref4 = _slicedToArray(_ref3, 2),\n            type = _ref4[0],\n            queries = _ref4[1];\n\n        queries.forEach(function (query, breakpoint) {\n          // We need to invert the query, such that it matches when we want the\n          // element to be hidden.\n          acc.push((0, _Utils.createRuleSet)((0, _Utils.createClassName)(type, breakpoint), \"not all and \".concat(query)));\n        });\n        return acc;\n      }, []);\n    }\n  }, {\n    key: \"shouldRenderMediaQuery\",\n    value: function shouldRenderMediaQuery(breakpointProps, onlyRenderAt) {\n      var _this3 = this;\n\n      breakpointProps = this._normalizeProps(breakpointProps);\n\n      if (breakpointProps.lessThan) {\n        var width = this._breakpoints[breakpointProps.lessThan];\n        var lowestAllowedWidth = Math.min.apply(Math, _toConsumableArray(onlyRenderAt.map(function (breakpoint) {\n          return _this3._breakpoints[breakpoint];\n        })));\n        return lowestAllowedWidth < width;\n      } else if (breakpointProps.greaterThan) {\n        var _width = this._breakpoints[this._findNextBreakpoint(breakpointProps.greaterThan)];\n\n        var highestAllowedWidth = Math.max.apply(Math, _toConsumableArray(onlyRenderAt.map(function (breakpoint) {\n          return _this3._breakpoints[breakpoint];\n        })));\n        return highestAllowedWidth >= _width;\n      } else if (breakpointProps.greaterThanOrEqual) {\n        var _width2 = this._breakpoints[breakpointProps.greaterThanOrEqual];\n\n        var _highestAllowedWidth = Math.max.apply(Math, _toConsumableArray(onlyRenderAt.map(function (breakpoint) {\n          return _this3._breakpoints[breakpoint];\n        })));\n\n        return _highestAllowedWidth >= _width2;\n      } else if (breakpointProps.between) {\n        // TODO: This is the only useful breakpoint to negate, but we’ll\n        //       we’ll see when/if we need it. We could then also decide\n        //       to add `oustide`.\n        var fromWidth = this._breakpoints[breakpointProps.between[0]];\n        var toWidth = this._breakpoints[breakpointProps.between[1]];\n        var allowedWidths = onlyRenderAt.map(function (breakpoint) {\n          return _this3._breakpoints[breakpoint];\n        });\n        return !(Math.max.apply(Math, _toConsumableArray(allowedWidths)) < fromWidth || Math.min.apply(Math, _toConsumableArray(allowedWidths)) >= toWidth);\n      }\n\n      return false;\n    }\n  }, {\n    key: \"_normalizeProps\",\n    value: function _normalizeProps(breakpointProps) {\n      if (breakpointProps.at) {\n        var fromIndex = this._sortedBreakpoints.indexOf(breakpointProps.at);\n\n        var to = this._sortedBreakpoints[fromIndex + 1];\n        return to ? {\n          between: [breakpointProps.at, to]\n        } : {\n          greaterThanOrEqual: breakpointProps.at\n        };\n      }\n\n      return breakpointProps;\n    }\n  }, {\n    key: \"_createBreakpointQuery\",\n    value: function _createBreakpointQuery(breakpointProps) {\n      breakpointProps = this._normalizeProps(breakpointProps);\n\n      if (breakpointProps.lessThan) {\n        var width = this._breakpoints[breakpointProps.lessThan];\n        return \"(max-width:\".concat(width - 0.02, \"px)\");\n      } else if (breakpointProps.greaterThan) {\n        var _width3 = this._breakpoints[this._findNextBreakpoint(breakpointProps.greaterThan)];\n\n        return \"(min-width:\".concat(_width3, \"px)\");\n      } else if (breakpointProps.greaterThanOrEqual) {\n        var _width4 = this._breakpoints[breakpointProps.greaterThanOrEqual];\n        return \"(min-width:\".concat(_width4, \"px)\");\n      } else if (breakpointProps.between) {\n        // TODO: This is the only useful breakpoint to negate, but we’ll\n        //       we’ll see when/if we need it. We could then also decide\n        //       to add `outside`.\n        var fromWidth = this._breakpoints[breakpointProps.between[0]];\n        var toWidth = this._breakpoints[breakpointProps.between[1]];\n        return \"(min-width:\".concat(fromWidth, \"px) and (max-width:\").concat(toWidth - 0.02, \"px)\");\n      }\n\n      throw new Error(\"Unexpected breakpoint props: \".concat(JSON.stringify(breakpointProps)));\n    }\n  }, {\n    key: \"_createBreakpointQueries\",\n    value: function _createBreakpointQueries(key, forBreakpoints) {\n      var _this4 = this;\n\n      return forBreakpoints.reduce(function (map, breakpoint) {\n        map.set(breakpointKey(breakpoint), _this4._createBreakpointQuery(_defineProperty({}, key, breakpoint)));\n        return map;\n      }, new Map());\n    }\n  }, {\n    key: \"_findNextBreakpoint\",\n    value: function _findNextBreakpoint(breakpoint) {\n      var nextBreakpoint = this._sortedBreakpoints[this._sortedBreakpoints.indexOf(breakpoint) + 1];\n\n      if (!nextBreakpoint) {\n        throw new Error(\"There is no breakpoint larger than \".concat(breakpoint));\n      }\n\n      return nextBreakpoint;\n    }\n  }, {\n    key: \"sortedBreakpoints\",\n    get: function get() {\n      return this._sortedBreakpoints;\n    }\n  }, {\n    key: \"dynamicResponsiveMediaQueries\",\n    get: function get() {\n      return Array.from(this._mediaQueries[BreakpointConstraint.at].entries()).reduce(function (acc, _ref5) {\n        var _ref6 = _slicedToArray(_ref5, 2),\n            k = _ref6[0],\n            v = _ref6[1];\n\n        return _objectSpread({}, acc, _defineProperty({}, k, v));\n      }, {});\n    }\n  }, {\n    key: \"largestBreakpoint\",\n    get: function get() {\n      return this._sortedBreakpoints[this._sortedBreakpoints.length - 1];\n    }\n  }]);\n\n  return Breakpoints;\n}();\n\nexports.Breakpoints = Breakpoints;","map":{"version":3,"mappings":"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","names":["breakpointKey","breakpoint","Array","isArray","join","BreakpointConstraint","Breakpoints","at","lessThan","greaterThan","greaterThanOrEqual","between","breakpoints","_classCallCheck","_defineProperty","fromWidth","throughWidth","fromBreakpoint","_this","findBreakpointAtWidth","undefined","throughBreakpoint","_sortedBreakpoints","slice","indexOf","width","find","i","nextBreakpoint","_breakpoints","values","max","length","valueBreakpoints","lastTuple","forEach","value","push","map","props","Object","keys","sort","a","b","breakpointAndValue","betweenCombinations","reduce","acc","b1","b2","_mediaQueries","_createBreakpointQueries","breakpointProps","_normalizeProps","breakpointIndex","sortedBreakpoints","findIndex","bp","fromBreakpointIndex","toBreakpointIndex","validKeys","selectedMediaQueries","mediaQueries","query","_this2","entries","type","queries","onlyRenderAt","lowestAllowedWidth","Math","min","_toConsumableArray","_this3","_findNextBreakpoint","highestAllowedWidth","toWidth","allowedWidths","fromIndex","to","Error","JSON","stringify","key","forBreakpoints","set","_this4","_createBreakpointQuery","Map","from","k","v"],"sources":["../src/Breakpoints.ts"],"sourcesContent":["import { MediaBreakpointProps } from \"./Media\"\nimport { createRuleSet, createClassName } from \"./Utils\"\n\n/**\n * A union of possible breakpoint props.\n */\nexport type BreakpointConstraintKey = keyof MediaBreakpointProps\n\ntype ValueBreakpointPropsTuple<SizeValue, BreakpointKey> = [\n  SizeValue,\n  MediaBreakpointProps<BreakpointKey>\n]\n\ntype Tuple = [string, string]\n\nfunction breakpointKey(breakpoint: string | Tuple) {\n  return Array.isArray(breakpoint) ? breakpoint.join(\"-\") : breakpoint\n}\n\nexport enum BreakpointConstraint {\n  at = \"at\",\n  lessThan = \"lessThan\",\n  greaterThan = \"greaterThan\",\n  greaterThanOrEqual = \"greaterThanOrEqual\",\n  between = \"between\",\n}\n\n/**\n * Encapsulates all breakpoint data needed by the Media component. The data is\n * generated on initialization so no further runtime work is necessary.\n */\nexport class Breakpoints<BreakpointKey extends string> {\n  static validKeys() {\n    return [\n      BreakpointConstraint.at,\n      BreakpointConstraint.lessThan,\n      BreakpointConstraint.greaterThan,\n      BreakpointConstraint.greaterThanOrEqual,\n      BreakpointConstraint.between,\n    ]\n  }\n\n  private _sortedBreakpoints: ReadonlyArray<string>\n  private _breakpoints: Record<string, number>\n  private _mediaQueries: Record<BreakpointConstraint, Map<string, string>>\n\n  constructor(breakpoints: { [key: string]: number }) {\n    this._breakpoints = breakpoints\n\n    this._sortedBreakpoints = Object.keys(breakpoints)\n      .map(breakpoint => [breakpoint, breakpoints[breakpoint]])\n      .sort((a, b) => (a[1] < b[1] ? -1 : 1))\n      .map(breakpointAndValue => breakpointAndValue[0] as string)\n\n    // List of all possible and valid `between` combinations\n    const betweenCombinations = this._sortedBreakpoints\n      .slice(0, -1)\n      .reduce(\n        (acc: Tuple[], b1, i) => [\n          ...acc,\n          ...this._sortedBreakpoints.slice(i + 1).map(b2 => [b1, b2] as Tuple),\n        ],\n        []\n      )\n\n    this._mediaQueries = {\n      [BreakpointConstraint.at]: this._createBreakpointQueries(\n        BreakpointConstraint.at,\n        this._sortedBreakpoints\n      ),\n      [BreakpointConstraint.lessThan]: this._createBreakpointQueries(\n        BreakpointConstraint.lessThan,\n        this._sortedBreakpoints.slice(1)\n      ),\n      [BreakpointConstraint.greaterThan]: this._createBreakpointQueries(\n        BreakpointConstraint.greaterThan,\n        this._sortedBreakpoints.slice(0, -1)\n      ),\n      [BreakpointConstraint.greaterThanOrEqual]: this._createBreakpointQueries(\n        BreakpointConstraint.greaterThanOrEqual,\n        this._sortedBreakpoints\n      ),\n      [BreakpointConstraint.between]: this._createBreakpointQueries(\n        BreakpointConstraint.between,\n        betweenCombinations\n      ),\n    }\n  }\n\n  public get sortedBreakpoints() {\n    return this._sortedBreakpoints as BreakpointKey[]\n  }\n\n  public get dynamicResponsiveMediaQueries() {\n    return Array.from(\n      this._mediaQueries[BreakpointConstraint.at].entries()\n    ).reduce((acc, [k, v]) => ({ ...acc, [k]: v }), {})\n  }\n\n  public get largestBreakpoint() {\n    return this._sortedBreakpoints[this._sortedBreakpoints.length - 1]\n  }\n\n  public findBreakpointsForWidths = (\n    fromWidth: number,\n    throughWidth: number\n  ) => {\n    const fromBreakpoint = this.findBreakpointAtWidth(fromWidth)\n    if (!fromBreakpoint) {\n      return undefined\n    }\n    const throughBreakpoint = this.findBreakpointAtWidth(throughWidth)\n    if (!throughBreakpoint || fromBreakpoint === throughBreakpoint) {\n      return [fromBreakpoint] as BreakpointKey[]\n    } else {\n      return this._sortedBreakpoints.slice(\n        this._sortedBreakpoints.indexOf(fromBreakpoint),\n        this._sortedBreakpoints.indexOf(throughBreakpoint) + 1\n      ) as BreakpointKey[]\n    }\n  }\n\n  public findBreakpointAtWidth = (width: number) => {\n    return this._sortedBreakpoints.find((breakpoint, i) => {\n      const nextBreakpoint = this._sortedBreakpoints[i + 1]\n      if (nextBreakpoint) {\n        return (\n          width >= this._breakpoints[breakpoint] &&\n          width < this._breakpoints[nextBreakpoint]\n        )\n      } else {\n        return width >= this._breakpoints[breakpoint]\n      }\n    }) as BreakpointKey | undefined\n  }\n\n  public toVisibleAtBreakpointSet(breakpointProps: MediaBreakpointProps) {\n    breakpointProps = this._normalizeProps(breakpointProps)\n    if (breakpointProps.lessThan) {\n      const breakpointIndex = this.sortedBreakpoints.findIndex(\n        bp => bp === breakpointProps.lessThan\n      )\n      return this.sortedBreakpoints.slice(0, breakpointIndex)\n    } else if (breakpointProps.greaterThan) {\n      const breakpointIndex = this.sortedBreakpoints.findIndex(\n        bp => bp === breakpointProps.greaterThan\n      )\n      return this.sortedBreakpoints.slice(breakpointIndex + 1)\n    } else if (breakpointProps.greaterThanOrEqual) {\n      const breakpointIndex = this.sortedBreakpoints.findIndex(\n        bp => bp === breakpointProps.greaterThanOrEqual\n      )\n      return this.sortedBreakpoints.slice(breakpointIndex)\n    } else if (breakpointProps.between) {\n      const between = breakpointProps.between\n      const fromBreakpointIndex = this.sortedBreakpoints.findIndex(\n        bp => bp === between[0]\n      )\n      const toBreakpointIndex = this.sortedBreakpoints.findIndex(\n        bp => bp === between[1]\n      )\n      return this.sortedBreakpoints.slice(\n        fromBreakpointIndex,\n        toBreakpointIndex\n      )\n    }\n    return []\n  }\n\n  public toRuleSets(keys = Breakpoints.validKeys()) {\n    const selectedMediaQueries = keys.reduce(\n      (mediaQueries, query) => {\n        mediaQueries[query] = this._mediaQueries[query]\n        return mediaQueries\n      },\n      {} as Record<BreakpointConstraint, Map<string, string>>\n    )\n\n    return Object.entries(selectedMediaQueries).reduce(\n      (acc: string[], [type, queries]) => {\n        queries.forEach((query, breakpoint) => {\n          // We need to invert the query, such that it matches when we want the\n          // element to be hidden.\n          acc.push(\n            createRuleSet(\n              createClassName(type, breakpoint),\n              `not all and ${query}`\n            )\n          )\n        })\n        return acc\n      },\n      []\n    )\n  }\n\n  public shouldRenderMediaQuery(\n    breakpointProps: MediaBreakpointProps,\n    onlyRenderAt: string[]\n  ): boolean {\n    breakpointProps = this._normalizeProps(breakpointProps)\n    if (breakpointProps.lessThan) {\n      const width = this._breakpoints[breakpointProps.lessThan]\n      const lowestAllowedWidth = Math.min(\n        ...onlyRenderAt.map(breakpoint => this._breakpoints[breakpoint])\n      )\n      return lowestAllowedWidth < width\n    } else if (breakpointProps.greaterThan) {\n      const width = this._breakpoints[\n        this._findNextBreakpoint(breakpointProps.greaterThan)\n      ]\n      const highestAllowedWidth = Math.max(\n        ...onlyRenderAt.map(breakpoint => this._breakpoints[breakpoint])\n      )\n      return highestAllowedWidth >= width\n    } else if (breakpointProps.greaterThanOrEqual) {\n      const width = this._breakpoints[breakpointProps.greaterThanOrEqual]\n      const highestAllowedWidth = Math.max(\n        ...onlyRenderAt.map(breakpoint => this._breakpoints[breakpoint])\n      )\n      return highestAllowedWidth >= width\n    } else if (breakpointProps.between) {\n      // TODO: This is the only useful breakpoint to negate, but we’ll\n      //       we’ll see when/if we need it. We could then also decide\n      //       to add `oustide`.\n      const fromWidth = this._breakpoints[breakpointProps.between[0]]\n      const toWidth = this._breakpoints[breakpointProps.between[1]]\n      const allowedWidths = onlyRenderAt.map(\n        breakpoint => this._breakpoints[breakpoint]\n      )\n      return !(\n        Math.max(...allowedWidths) < fromWidth ||\n        Math.min(...allowedWidths) >= toWidth\n      )\n    }\n    return false\n  }\n\n  public valuesWithBreakpointProps = <SizeValue>(\n    values: SizeValue[]\n  ): Array<ValueBreakpointPropsTuple<SizeValue, BreakpointKey>> => {\n    type ValueBreakpoints = [SizeValue, string[]]\n    const max = values.length\n    const valueBreakpoints: ValueBreakpoints[] = []\n    let lastTuple: ValueBreakpoints\n    this._sortedBreakpoints.forEach((breakpoint, i) => {\n      const value = values[i]\n      if (i < max && (!lastTuple || lastTuple[0] !== value)) {\n        lastTuple = [value, [breakpoint]]\n        valueBreakpoints.push(lastTuple)\n      } else {\n        lastTuple[1].push(breakpoint)\n      }\n    })\n\n    return valueBreakpoints.map(([value, breakpoints], i) => {\n      const props: MediaBreakpointProps<any> = {}\n      if (i === valueBreakpoints.length - 1) {\n        props.greaterThanOrEqual = breakpoints[0]\n      } else if (breakpoints.length === 1) {\n        props.at = breakpoints[0]\n      } else {\n        // TODO: This is less than ideal, would be good to have a `through`\n        //       prop, which unlike `between` is inclusive.\n        props.between = [breakpoints[0], valueBreakpoints[i + 1][1][0]]\n      }\n      return [value, props] as ValueBreakpointPropsTuple<\n        SizeValue,\n        BreakpointKey\n      >\n    })\n  }\n\n  private _normalizeProps(\n    breakpointProps: MediaBreakpointProps\n  ): MediaBreakpointProps {\n    if (breakpointProps.at) {\n      const fromIndex = this._sortedBreakpoints.indexOf(breakpointProps.at)\n      const to = this._sortedBreakpoints[fromIndex + 1]\n      return to\n        ? { between: [breakpointProps.at, to] }\n        : { greaterThanOrEqual: breakpointProps.at }\n    }\n    return breakpointProps\n  }\n\n  private _createBreakpointQuery(\n    breakpointProps: MediaBreakpointProps\n  ): string {\n    breakpointProps = this._normalizeProps(breakpointProps)\n    if (breakpointProps.lessThan) {\n      const width = this._breakpoints[breakpointProps.lessThan]\n      return `(max-width:${width - 0.02}px)`\n    } else if (breakpointProps.greaterThan) {\n      const width = this._breakpoints[\n        this._findNextBreakpoint(breakpointProps.greaterThan)\n      ]\n      return `(min-width:${width}px)`\n    } else if (breakpointProps.greaterThanOrEqual) {\n      const width = this._breakpoints[breakpointProps.greaterThanOrEqual]\n      return `(min-width:${width}px)`\n    } else if (breakpointProps.between) {\n      // TODO: This is the only useful breakpoint to negate, but we’ll\n      //       we’ll see when/if we need it. We could then also decide\n      //       to add `outside`.\n      const fromWidth = this._breakpoints[breakpointProps.between[0]]\n      const toWidth = this._breakpoints[breakpointProps.between[1]]\n      return `(min-width:${fromWidth}px) and (max-width:${toWidth - 0.02}px)`\n    }\n    throw new Error(\n      `Unexpected breakpoint props: ${JSON.stringify(breakpointProps)}`\n    )\n  }\n\n  private _createBreakpointQueries(\n    key: BreakpointConstraintKey,\n    forBreakpoints: ReadonlyArray<string | [string, string]>\n  ) {\n    return forBreakpoints.reduce<Map<string, string>>((map, breakpoint) => {\n      map.set(\n        breakpointKey(breakpoint),\n        this._createBreakpointQuery({\n          [key]: breakpoint,\n        })\n      )\n      return map\n    }, new Map())\n  }\n\n  private _findNextBreakpoint(breakpoint: string) {\n    const nextBreakpoint = this._sortedBreakpoints[\n      this._sortedBreakpoints.indexOf(breakpoint) + 1\n    ]\n    if (!nextBreakpoint) {\n      throw new Error(`There is no breakpoint larger than ${breakpoint}`)\n    }\n    return nextBreakpoint\n  }\n}\n"]},"metadata":{},"sourceType":"script"}